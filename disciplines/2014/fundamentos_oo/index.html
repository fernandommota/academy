<!doctype html>
<html>
	<head>
		<meta charset="utf-8">		

		<link rel="stylesheet" href="../../../css/styles.css">
		<link rel="stylesheet" href="../../../lib/bootstrap/css/bootstrap.min.css">
		

		<script src="../../../js/jquery-2.1.1.min.js"></script>
		<script src="../../../lib/bootstrap/js/bootstrap.min.js"></script>

		<!--[if lt IE 9]>
		<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
	</head>
	<body>
		<h3>Avisos</h3>
			<blockquote>				
				<a class="btn btn-primary btn-lg" href="files/lista_1.pdf" target="no_blank" title="Download">
					<span class="glyphicon glyphicon-download-alt"></span>
				</a>
				lista 1 de exercicios.<strong>Entrega até dia 05/09/2014.</strong>

				<a class="btn btn-primary btn-lg" href="files/package_ufms.zip" target="no_blank" title="Download">
					<span class="glyphicon glyphicon-download-alt"></span>
				</a>
				Pacote gabarito exercício 2
				
				<a class="btn btn-primary btn-lg" href="files/lista1_notas.pdf" target="no_blank" title="Download">
					<span class="glyphicon glyphicon-download-alt"></span>
				</a>
				Notas
			</blockquote>

			<blockquote class="alert">				
				<a class="btn btn-primary btn-lg" href="files/lista2.pdf" target="no_blank" title="Download">
					<span class="glyphicon glyphicon-download-alt"></span>
				</a>
				lista 2 de exercicios.<strong>Entrega até dia 16/09/2014.</strong>

				<a class="btn btn-primary btn-lg" href="files/lista2_gabarito.pdf" target="no_blank" title="Download">
					<span class="glyphicon glyphicon-download-alt"></span>
				</a>
				Gabarito

				<a class="btn btn-primary btn-lg" href="files/lista2_dez.zip" target="no_blank" title="Download">
					<span class="glyphicon glyphicon-download-alt"></span>
				</a>
				Gabarito ex. 10
			</blockquote>

			<blockquote class="alert alert-warning">				
				<a class="btn btn-primary btn-lg" href="files/lista3.pdf" target="no_blank" title="Download">
					<span class="glyphicon glyphicon-download-alt"></span>
				</a>
				lista 3 de exercicios.<strong>Entrega até dia 03/11/2014.</strong>

			</blockquote>

		<hr>

		<h3>Provas</h3>
			<blockquote class="alert alert-warning">				
				<a class="btn btn-primary btn-lg" href="files/P1_FOO_gabarito.pdf" target="no_blank" title="Download">
					<span class="glyphicon glyphicon-download-alt"></span>
				</a>
				Gabarito prova 01

			</blockquote>
		<hr>
		<h3>Horário de atendimento</h3>
		??
		<hr>
		<h3>Avaliação</h3>
			<ul>
				<li>2 Provas teóricas: <var>P1</var> e <var>P2</var></li>
				<li>1 Prova optativa: <var>PO</var></li>
				<li>1 Trabalhos práticos: <var>T1</var></li>
				<li>4 Listas de exercício: <var>L1</var>, <var>L2</var>, <var>L3</var> e <var>L4</var></li>
			</ul>
			
			<strong>Média de aproveitamento:</strong> 
			(((<var>P1</var> + <var>P2</var>) / 2) * 0.6) + (<var>T1</var> * 0.2) + ((<var>L1</var> + <var>L2</var> + <var>L3</var> + <var>L4</var>) * 0.2))) 

		<hr>	
		<h3>Datas</h3>
			<strong>As aulas serão ministradas as quartas e sextas-feiras, das 21:00 às 23:00.</strong>
			<iframe src="https://www.google.com/calendar/embed?showTitle=0&amp;showDate=0&amp;showPrint=0&amp;showCalendars=0&amp;mode=MONTH&amp;height=400&amp;wkst=1&amp;hl=pt_BR&amp;bgcolor=%23ffffff&amp;src=lno19j9n65nhctft123vn7158s%40group.calendar.google.com&amp;color=%232952A3&amp;ctz=America%2FCampo_Grande" style=" border-width:0 " width="100%" height="400" frameborder="0" scrolling="no"></iframe>
		<hr>

		<h3>Ementa</h3>
		<ul class="list-group ementa">
			<li class="list-group-item">
    			<h4>Fundamentos da Programação Orientada a Objetos</h4>
    			<ul>
					<li>Objeto</li>
					<li>Classe</li>
					<li>Membros de classe</li>
				</ul>				
				<!-- *************************   Content ******************************************-->
    			<button class="btn btn-default" onclick="showContent(this);">Exibir</button>
				<div class="hide">
					<hr>

					<blockquote class="blockquote-reverse">
						Agradecimento ao professor Marcelo Ferreira Siqueira pelo material utilizado nesta disciplina.
						<footer><a href="http://lattes.cnpq.br/7340736676138238" target="no_blank">Currículo Lattes</a></footer>
					</blockquote>

					<blockquote>
						Aula 1 - Introdução à Orientação a Objetos
						<a class="btn btn-primary btn-lg" href="files/aula01.pdf" target="no_blank" title="Download">
							<span class="glyphicon glyphicon-download-alt"></span>
						</a>
					</blockquote>

					<blockquote>
						Aula 2 - Introdução à Orientação a Objetos (Continuação)
						<a class="btn btn-primary btn-lg" href="files/aula02.pdf" target="no_blank" title="Download">
							<span class="glyphicon glyphicon-download-alt"></span>
						</a>
					</blockquote>
				</div>
  			</li>
			<li class="list-group-item">
    			<h4 class="list-group-item-heading">Propriedades da Orientação a Objetos</h4>
    			<ul>
					<li>Herança
						<!-- *************************   Content ******************************************-->
    			<button class="btn btn-default" onclick="showContent(this);">Exibir</button>
				<div class="hide">
					<hr>
					<h4>Herança</h4>
					
					<blockquote class="blockquote-reverse">
						Códigos disponibilizados para esta aula (herança).
						<a class="btn btn-primary btn-lg" href="files/heranca.zip" target="no_blank" title="Download">
							<span class="glyphicon glyphicon-download-alt"></span>
						</a>
					</blockquote>

					<blockquote class="blockquote">
						<p>O conceito de herança esta fundamentado na definição de uma classe com base em outra.</p>
						<p>A outra classe usada como referencial pode ser chamada de superclasse, classe-mãe, classe-base ou generalização.</p>
						<p>A nova classe criada a partir da outra passa a ser subclasse, classe-filha, classe derivada ou especialização. Podemos redefinir métodos e criar novos atributos na subclasse.</p>
					</blockquote>

					<blockquote class="blockquote">
						<p>Sobreposição de métodos é quando em herança podemos definir novos métodos e atributos na subclasse, podemos também redefinir um método na subclasse com a mesma assinatura do método da superclasse.</p>
					</blockquote>

					<blockquote class="blockquote">
						<p>Quando criamos um objeto de uma subclasse, devemos lembrar que ao executar o seu construtor primeiramente será executado o construtor da superclasse de forma automática.</p>
						<p>Podemos executar na subclasse qualquer construtor da superclasse utilizando o comando <strong>super</strong>.</p>
					</blockquote>

					<blockquote class="blockquote">
						<p>Uma classe abstrata é desenvolvida para representar classes e conceitos abstratos.</p>
						<p>A classe abstrata é sempre uma superclasse que não permite que nenhum objeto seja criado a partir dela, ou seja, não se pode executar a operação de new usando uma classe abstrata.</p>
					</blockquote>

					<blockquote class="blockquote">
						<p>Os modificadores de acesso são palavras reservadas que modificam a forma de acesso a classes, métodos e/ou atributos.</p>
						<p>Classe final é quando uma classe não pode ser herdada por nenhuma outra. Um exemplo de classe final é a String.</p>
						<p>A razão para uso do modificador final é garantir certas regras de segurança ou projeto sejam seguidas.</p>
						<p>Métodos do tipo final não podem ser redefinidos, ou seja, caso você herde de uma classe que contenha métodos com esse modificador, esses métodos não podem ser sobrescritos (override) na subclasse.</p>
						<p>Por exemplo, você possui um método final <code>validarSenha()</code>, alguém mal-intencionado poderia alterar esse método em uma subclasse e passar a usar esse método em vez do definido pelo arquiteto do sistema.</p>
					</blockquote>

					<div class="alert alert-success" role="alert"><h4>Exercícios de fixação:</h4>
						Defina as seguintes classes que representam um sistema de bibliotecas, Ps. para cada livro emprestado um registro de empréstimo deve ser realizado:
						<ul>
							<li>Crie a classe Livro com os seguintes atributos: autor, ano de publicação, editora, nome do livro e código.</li>
							<li>Crie a classe Pessoa com os seguintes atributos: nome, idade, endereço e CPF.</li>
							<li>Na classe pessoa defina o método <code>imprimirMatricula</code>, onde os atributos nome e CPF devem ser impressos.</li>
							<li>Crie a classe Docente herdando da classe Pessoa, nesta classe deve ser inserida um atributo que represente o número de matricula geral do docente que possui no máximo 8 caracteres. Ex. "CPCX2014" </li>
							<li>Na classe Docente defina o método <code>imprimirMatricula</code>, onde os atributos nome e código de matricula geral do docente devem ser impressos.</li>
							<li>Crie a classe Aluno herdando da classe Pessoa, nesta classe deve ser inserida um atributo que represente o número de matricula geral do aluno que possui no máximo 6 números. Ex. "201418" </li>
							<li>Na classe Aluno defina o método <code>imprimirMatricula</code>, onde os atributos nome e código de matricula geral do aluno devem ser impressos.</li>
							<li>Crie a classe abstrata Empréstimo com os seguintes métodos e argumentos:
								<ul>
									<li><code>devolver();</code></li>
									<li><code>renovar(quantidadeDias);</code></li>								
								</ul>							
							</li>							
							<li>Crie as classes EmprestimoDocente e EmprestimoAluno, ambas devem herdar da classe Empréstimo e em seu construtor devem ser instanciados os atributos Livro e Docente, Livro e Aluno respectivamente.</li>
						</ul>		
					</div>

					<blockquote class="blockquote">
						<p>Formas de Herança:</p>
						<ul>
							<li><strong>Especialização</strong>. Provavelmente, o uso mais comum de herança é por especialização. Neste uso, a classe nova é uma forma especializada da classe pai, mas satisfaz as especificações da classe pai em todos os aspectos relevantes.</li>
							<li><strong>Generalização</strong>. Usar herança por generalização é, de certa forma, o oposto de especialização. Aqui, uma subclasse estende o comportamento da classe pai para criar um tipo mais geral de objeto. Generalização é frequentemente aplicada quando construímos uma base de classes existentes que não desejamos modifícar ou não podemos modifícar.</li>
							<li><strong>Limitação</strong>. Limitação ocorre quando o comportamento da subclasse é menor ou mais restritivo do que o comportamento da classe pai. Assim como generalização, limitação ocorre mais frequentemente quando um programador está construindo sobre uma base de classes existentes que não deveria, ou não pode, ser modifícada.</li>
							<li><strong>Especificação</strong>. Um uso frequente de herança é para garantir que classes mantenham uma certa interface comum, isto é, implementem os mesmos métodos. A classe pai pode ser uma combinação de operações implementadas e operações que são "deixadas" para ser implementadas pelas classes fílhas. Frequentemente, não há mudança de interface de nenhuma ordem entre a classe pai e a classe fílha: a classe fílha meramente implementa o comportamento descrito, mas não implementado, pela classe pai. Especificação é de fato um caso especial de especialização, exceto que as subclasses não são refinamentos de um tipo existente, mas sim realizações de uma especificação abstrata e incompleta. Em tais casos, a classe pai é algumas vezes conhecida como classe de especificação abstrata.</li>
							<li><strong>Combinação</strong>. Uma situação comum é uma subclasse representar uma combinação de características de duas ou mais classes pai. Um monitor de ensino pode possuir características tanto de um professor quanto de um estudante e pode, portanto, comportar-se como ambos. A capacidade de uma classe herdar de duas ou mais classes pais é conhecida como herança múltipla.</li>
						</ul>
					</blockquote>

					<blockquote class="blockquote">
						<p>A Regra "é um" e a Regra "tem um":</p>
						<ul>
							<li>Um entendimento de duas formas diferentes de relacionamento entre classes e objetos é fundamental para saber como e quando aplicar técnicas de reuso de software orientado a objetos. Estes dois relacionamentos são conhecidos informalmente como "é um" e "tem um" (ou "parte de").</li>
							<li>O relacionamento "é um" entre dois conceitos é satisfeito quando o primeiro é uma especialização do segundo.</li>
							<li>Por exemplo. Florista é um Vendedor, um Cachorro é um Mamífero e assim por diante.</li>
							<li>Para determinar se o conceito X é uma instância especializada do conceito Y, simplesmente forme a sentença "Um X é um Y". Se a sentença "soa bem", isto é, se ela parece corresponder à experiência do dia-a-dia, você pode assumir que X e Y possuem o relacionamento é um.</li>
							<li>O relacionamento tem um, por outro lado, é satisfeito quando o segundo conceito é um componente do primeiro, mas os dois não são, em qualquer hipótese, a mesma coisa, não importa quão abstrata seja a generalidade. Por exemplo, um Carro tem um Motor e, claramente, não faz sentido dizer que um Carro é um Motor ou um Motor é um Carro. Entretanto, um Carro é um Veículo, que por sua vez é um Meio De Transporte.</li>
							<li>Mais uma vez, o teste para o relacionamento tem um é simplesmente formar uma sentença da forma "um X tem um Y" e deixar o senso comum dizer se o resultado soa razoável.</li>
						</ul>
					</blockquote>

					<blockquote class="blockquote">
						<p>Benefícios do Uso de Herança:</p>
						<ul>
							<li><strong>Reusabilidade de código.</strong> Quando comportamento é herdado de uma outra classe, o código que fornece aquele comportamento não precisa ser reescrito. Isto parece óbvio, mas as implicações são importantes. Muitos programadores gastam muito do tempo deles reescrevendo código que eles escreveram muitas vezes antes. Por exemplo, para encontrar um padrão em uma cadeia ou inserir um novo elemento em uma tabela. Com técnicas de orientação a objetos, estas funções podem ser escritas apenas uma vez e reutilizadas.</li>
							<li><strong>Compartilhamento de código.</strong> Compartilhamento de código ocorre em muitos níveis com técnicas orientadas a objetos. Uma forma de compartilhamento se dá quando muitos usuários ou projetos podem usar as mesmas classes. Uma outra ocorre quando duas ou mais classes desenvolvidas por um único programador como parte de um projeto herda de uma única classe pai. Quando isto acontece, dois ou mais tipos de objetos compartilharão o código que eles herdaram.</li>
							<li><strong>Consistência de interface.</strong> Quando duas ou mais classes herdam da mesma superclasse, podemos estar certos de que o comportamento que elas herdaram sería o mesmo em todas as classes. Logo, é mais fácil garantir que interfaces para objetos semelhantes sejam, de fato, semelhantes e que o usuário não se depare com um conjunto confuso de objetos que são quase os mesmos mas se comportam e interagem de forma bem diferente.</li>
							<li><strong>Componentes de software.</strong> Herança permite que programadores construam componentes de software reutilizáveis. O objetivo é permitir o desenvolvimento de aplicações novas que requeiram pouca ou nenhuma codificação. Várias bibliotecas de classes reutilizáveis já se encontram disponíveis comercialmente e podemos esperar muito mais com o passar do tempo.</li>
							<li><strong>Prototipação rápida.</strong> Quando um sistema de software é grandemente construído com base em componentes reutilizáveis, o tempo de desenvolvimento pode ser concentrado em entender a parte nova do sistema. Logo, sistemas de software podem ser gerados mais facilmente e mais rapidamente, levando a um estilo de programação conhecido como prototipação rápida ou programação exploratória.</li>
							<li><strong>Ocultamento de informação.</strong> Um programador que reutiliza um componente de software necessita apenas entender a natureza do componente e sua interface. Não há a necessidade do programador ter informação detalhada a respeito de fatos como, por exemplo, as técnicas usadas para implementar o componente. Logo, a interconexão entre sistemas de software é reduzida e, consequentemente, a complexidade também é reduzida.</li>
						</ul>
					</blockquote>

					<blockquote class="blockquote">
						<p>Custos do Uso de Herança:</p>
						<ul>
							<li><strong>Velocidade de execução.</strong> Difícilmente, ferramentas de software de propósito geral são tão rápidas quanto aquelas desenvolvidas cuidadosamente para um propósito específico. Logo, métodos herdados, que devem lidar com subclasses arbitrárias são frequentemente mais lentos do que código especializado. Ainda assim, a preocupação com eficiência é geralmente desnecessária. Primeiro, a diferença e frequentemente pequena. Segundo, a redução em velocidade de execução pode ser balanceada por um aumento da velocidade de desenvolvimento de software. Finalmente, a maioria dos programadores não possui a mínima ideia de como o tempo de execução está sendo usado no programa. É muito melhor desenvolver um sistema que funcione, monitorá-lo para descobrir onde o
tempo de execução está sendo usado e melhorar aquelas seções, do que gastar uma quantidade desordenada de tempo se preocupando com eficiência no início do projeto.</li>
							<li><strong>Tamanho do programa.</strong> O uso de qualquer biblioteca de software em geral acarreta o aumento de tamanho do programa, o que não acontece com sistemas construídos através de um projeto específico. Embora este gasto possa ser substancial, quando o custo de memória for reduzido a níveis insignificantes. Conter custos de desenvolvimento e produzir código de alta qualidade e livre de erro são preocupações que se tornaram muito mais importantes do que limitar o tamanho dos programas.</li>
							<li><strong>Overhead de envio de mensagens.</strong> Muito do que tem sido feito do fato que envio de mensagens é por natureza uma operação mais custosa do que chamada de procedimento. Assim como velocidade de execução, entretanto, a preocupação neste caso também é supervalorizada, pois a diferença nos custos de envio de mensagens e chamada de procedimento é marginal. Talvez, duas ou três instruções adicionais de linguagem de montagem e um gasto adicional de 10 porcento do tempo total. Este custo, como muitos outros, pode ser balanceado pelos benefícios das técnicas de orientação a objetos.</li>
							<li><strong>Complexidade do programa.</strong> Embora a programação orientada a objetos seja tida como uma solução para a complexidade do software, o uso demasiado de herança pode simplesmente substituir uma forma de complexidade por outra. Entender o uso de controle de um programa que utiliza herança pode requerer várias varreduras no grafo de herança. Isto é conhecido como o problema do iô-iô.</li>							
						</ul>
					</blockquote>
			
			</div>
					</li>
					<li>Polimorfismo
						<!-- *************************   Content ******************************************-->
    		<button class="btn btn-default" onclick="showContent(this);">Exibir</button>
			<div class="hide">
				<hr>
				<h4>Polimorfismo</h4>
					<blockquote class="blockquote">
						<p>O termpo polimorfismo é originário do grego e significa "muitas formas": <em>poli</em> significa muitas e <em>morphos</em> significa formas.</p>
						<p>Em linguagens de programação, um objeto polimórfico é qualquer entidade, tal como uma variável ou argumento de função, que pode armazenar valores de tipos diferentes durante o curso de execução de um programa. Funções polimórficas são aquelas que possuem argumentos polimórficos.</p>
						<p>Polimorfismo é um resultado natural do relacionamento "é um" e dos mecanismos de passagem de mensagem, herança e substituição.</p>												
					</blockquote>
					<blockquote class="blockquote">
						<p>A decisão sobre qual método executar, o da superclasse ou da subclasse ocorre em tempo de execução, ou seja, a chamada ao método permanece o mesmo, o que varia é a execução do operador <code>new</code>.</p>
<pre>
public class Pessoa {
    private String nome;
    private String endereco;
    private int rg;
    
    public void imprime(){
        System.out.println("Método imprime da classe Pessoa!"); 
    }
}

public class Aluno extends Pessoa{
    @Override
    public void imprime(){
        System.out.println("Método imprime da classe Aluno!");
    }
}

public class Main {
    public static void main(String args[]){
        <kbd>Pessoa pessoa = new Pessoa();</kbd>
        <kbd>Pessoa aluno = new Aluno();</kbd>
        
        pessoa.imprime();
        aluno.imprime();
    }
}					
		
</pre>												
					</blockquote>

					<blockquote class="blockquote">
						<p>Polimorfismo e construtores:</p>
						<ul>
							<li>Toda Classe tem pelo menos um construtor, que deve ser definido com o mesmo nome da classe.</li>
							<li>Toda vez que o objeto for criado pelo operador <code>new</code>, o método construtor correspondente será executado automaticamente.</li>
<pre>
public class Pessoa {
    public Pessoa(){
        System.out.println("Início do construtor da classe Pessoa!");
        imprime();
        System.out.println("Fim do construtor da classe Pessoa!");
    }
}

public class Aluno {
    public Aluno(){
        System.out.println("Início do construtor da classe Aluno!");
        imprime();
        System.out.println("Fim do construtor da classe Aluno!");
    }
}

public class Main {
    public static void main(String args[]){
        Pessoa aluno = new Aluno();
    }
}
</pre>
						</ul>
					</blockquote>

					<blockquote class="blockquote">
						<p>O <strong>polimorfismo de sobrecarga</strong> ocorre quando um nome de função está associado a mais de dois corpos de função, ou seja, quando um nome de função for usado mais de uma vez com diferentes tipos de parâmetro.</p>
<pre>
public class Pessoa {
    public void soma(int a, int b){
        System.out.println("A soma dos inteiros é: "+(a+b));
    }
    
    public void soma(double a, double b){
        System.out.println("A soma dos reais é: "+(a+b));
    }
}

public class Main {
    public static void main(String args[]){
        Pessoa aluno = new Aluno();

        aluno.soma(32, 32);
		aluno.soma(32.43, 32.34);
    }
}
</pre>						
					</blockquote>

					<blockquote class="blockquote">
						<p>Algumas linguagens de programação permitem que haja uma conversão implícita entre certos tipos de dados.</p>
						<p>Estas conversões implícitas são realizadas automaticamente pelo compilador e são denominadas de <strong>coerção</strong>.</p>
						<p>Coerções são limitadas a situacões onde não há perda de informação, como na conversão de um valor inteiro para o valor real correspondente.</p>
<pre>
public class Pessoa {
    public void soma(double a, double b){
        System.out.println("A soma dos reais é: "+(a+b));
    }
}

public class Main {
    public static void main(String args[]){
        Pessoa aluno = new Aluno();

        aluno.soma(32, 32);
    }
}
</pre>					
					<p>No caso acima, o valor 32 foi coargido para 32.0 pelo compilador JAVA.</p>
					<hr>
					<p>Segundo caso:</p>	
<pre>
public class Pessoa {
    public void soma(int a, int b){
        System.out.println("A soma dos inteiros é: "+(a+b));
    }
    
    public void soma(double a, double b){
        System.out.println("A soma dos reais é: "+(a+b));
    }
}

public class Main {
    public static void main(String args[]){
        Pessoa aluno = new Aluno();
        
        aluno.soma(7.5,4.3);
        aluno.soma(7.5,4);
        aluno.soma(7,4.3);
        aluno.soma(7,4);
    }
}
</pre>
					<p>Aqui, notamos a presença tanto de sobrecarga quanto de coerção, pois no segundo e no terceiro envios da mensagem soma, o valor inteiro foi
coargido para o real correspondente. Já no primeiro e no último envio da mensagem soma, temos apenas sobrecarga.</p>	
					</blockquote>				

					<div class="alert alert-success" role="alert"><h4>Exercícios de fixação:</h4>
						<p>1) Qual é a saída produzida pela aplicação a seguir? Justifique sua resposta.</p>	
<pre>
public class Sobrecarga {

    public static void main(String args[]) {
        class A {

            public int foo(int i) {
                return i + 1;
            }
        }
        class B extends A {

            public int foo(float f) {
                return (int) (f + 10);
            }
        }
        B b = new B();
        System.out.println("Surpresa: " + b.foo(2));
    }

}
</pre>	
						<p>2) Considere o trecho de código dado a seguir:</p>
<pre>
public class Super {

    public Super() {
        printThree();
    }

    void printThree() {
        System.out.println("three");
    }
}

public class Test extends Super {

    int indiana = (int) Math.PI;

    public static void main(String args[]) {
        Test t = new Test();
        t.printThree();
    }
    
    void printThree() {
        System.out.println(indiana);
    }
}
</pre>
					<ul>
						<li>(a) Qual é a saída produzida pela aplicação do trecho acima? Justifique sua resposta.</li>
						<li>(b) Com base neste exemplo, argumente contra o fato de um construtor poder invocar um método que foi sobrescrito.</li>
					</ul>
					

					</div>					
					</li>

					<li>Encapsulamento
						<!-- *************************   Content ******************************************-->
						<button class="btn btn-default" onclick="showContent(this);">Exibir</button>
						<div class="hide">	
							<hr>
							<h4>Encapsulamento</h4>

							<blockquote class="blockquote">
								<p>O encapsulamento é o processo de proteger os membros de uma classe (atributos e métodos), permitindo que somente os membros necessários (públicos) sejam acessados pelos usuários da classe.</p>
							</blockquote>

							<blockquote class="blockquote">
								O encapsulamento apresenta as seguintes vantagens:
								<ul>
									<li><strong>Facilidade de manutenção.</strong> A manutenção de classes pode ser efetuada de maneira isolada, ou seja, se um atributo tiver seu formato alterado, os usuários dessa classe poderão continuar a usá-la sem se preocupar com a alteração.</li>
									<li><strong>Redução do acoplamento.</strong> Quanto menor o acoplamento entre classes, maior pode ser a reutilização dessa classe.</li>
									<li><strong>Segurança das informações.</strong> Toda comunicação com o objeto ocorre por meio dos métodos modificadores e de acesso (setXXX() e getXXX()), oferecendo segurança na atribuição de novos valores.</li>
								</ul>
							</blockquote>

							<blockquote class="blockquote">
								<p>Há três modificadores de acesso que devem ser explicitamente informados na criação de uma classe, método ou atributo. Esses modificadores são conhecidos por:</p>
									<ul>
										<li><strong>public.</strong> O acesso é liberado para qualquer nível de acesso.</li>
										<li><strong>protected.</strong> O acesso é protegido a nível de pacote e herança (dentro ou fora do mesmo pacote).</li>
										<li><strong>private.</strong> Quando declarado a classe, método ou atributo são extritamente reservadas a classe em que são declaradas.</li>
									</ul>
								<p>A ausência do modificador de acesso faz o membro ser <i>friendly</i> (visível ao nível de pacote).</p>
							</blockquote>

							<blockquote class="blockquote">
								<p><strong>Acoplamento fraco e forte:</strong></p>
								<p>Acoplamento forte (Exemplo 1):</p>
<pre>
class Servidor {
  public void mensagem(MeuTipo x) {
    // código aqui
    x.façaAlgo(Object dados); // dados e x estão acoplados
                              // (se interface de dados mudar x terá que mudar)
    // mais código
  }
}
</pre>
								<p>Acoplamento forte (Exemplo 2):</p>
								<ul>
									<li>Objeto a manda uma mensagem para objeto b</li>
									<li>b usa um parâmetro da mensagem para decidir o que fazer</li>
								</ul>
<pre>
class Lampada {
  public final static int ON = 0;

  public void setLampada(int valor) {
    if(valor == ON) {
      // liga lampada
    } else if(valor == 1) {
      // desliga lampada
    } else if(valor == 2) {
      // pisca
    }
  }
}

Lampada lampapa = new Lampada();
lampada.setLampada(Lampada.ON);
lampada.setLampada(2);
</pre>
								<p>Acoplamento fraco (Exemplo 2):</p>
								<ul>
									<li>Solução: decompor a operação em múltiplas operações primitivas</li>
								</ul>
<pre>
class Lampada {
  public void on() { // liga lampada }
  public void off() { // desliga lampada }
  public void pisca() { // pisca }
}

Lampada lampada = new Lampada();
lampada.on();
lampada.pisca();
</pre>
							</blockquote>

							<div class="alert alert-success" role="alert"><h4>Exercícios de fixação:</h4>
							<p>1) Considere o código fonte a seguir e faça as modificações necessárias utilizando POO.</p>	
<pre>
package venda;

private class Carro {
	public int ano;
	public String modelo;

	public void setAno(int ano){...}
	public int getAno(){...}
	private void setModelo(String modelo){...}
	private void getModelo(){...}
}

public class Uno extends Carro {
	public int numeroSerie;

	public Uno(){
        super.getModelo();
    }

	public void setNumeroSerie(int numeroSerie){...}
	public int getNumeroSerie(){...}
}

protected class Gol extends Carro {
	public int numeroSerie;

	public void setNumeroSerie(int numeroSerie){...}
	public int getNumeroSerie(){...}
}
</pre>	
<pre>
package aluguel;

private class golVermelho extends Gol {
	...
}

private class golVerde extends Gol {
	...
}

public class golVerde2 extends golVerde {
	...
}
</pre>
									<p>2) Considere o trecho de código dado a seguir. Faça um <i>refactory</i> neste código diminuindo o nível de acoplamento.</p>
<pre>
public class Pessoa{
    private String nome;
    private String endereco;
	
	public Pessoa(String nome){
		this.nome=nome;
	}
	public Pessoa(){
		this.nome="Não informado"
	}

	.
	.
	.
}

public class Escola{
    private String nome;
    private String endereco;
	
	.
	.
	.
}


public class Aluno{
	private Pessoa nome;
	private Escola escola;

	public Aluno(int opcao, String disciplina){
		if(opcao==1)
			//realiza matricula
		else if(opcao==2)
			//excluí matricula
		else if(opcao==3)
			// expulsa aluno
	}
	public void insereConceito(Double nota){
		if(nota>=8)
			//conceito A
		else if(nota >=6)
			//conceito B
		else
			//conceito C
	}
}
</pre>
								
							</div>
						</div>			
					</li>
				</ul>

				
			
  			</li>
			<li class="list-group-item">
    			<h4 class="list-group-item-heading">Classes e métodos abstratos</h4>    			
  			</li>
			<li class="list-group-item">
    			<h4 class="list-group-item-heading">Interfaces</h4>

<!-- *************************   Content ******************************************-->
						<button class="btn btn-default" onclick="showContent(this);">Exibir</button>
						<div class="hide">	
							<hr>
							<h4>Interfaces</h4>

							<blockquote class="blockquote">
								<p>Um interface em Java não representa exatamente uma classe, mas deve ser gravada em um arquivo próprio com a extensão <i>.java</i>.</p>
								<p>Em uma interface definimos somente atributos estáticos e constantes e os métodos são todos abstratos.</p>
								<p>Para definir uma interface devemos usar a palavra reservada <i>interface</i> no lugar da palavra <i>class</i>.
<pre>
public interface Mobilidade {

}
</pre>
								</p>
								<p>Para que um classe classe possa usar uma interface é necessário que a classe implemente a interface com o uso da palavra reservada <i>implements</i>.
<pre>
public class Robo implements Mobilidade {

}
</pre>
								</p>
								<p>Um exemplo prático do uso de interfaces é a API JDBC presente na linguagem Java. Todos os fabricantes como Sybase, Oracle, Sun e MS SQL Server implementam as interfaces definidas pela API JDBC, mas cada um implementa os métodos dessas interfaces de uma forma diferente.</p>
								<p>A vantagem está em tornar o uso da API JDBC totalmente independente da implementação usada.</p>	
							</blockquote>

							<blockquote class="blockquote">
								Uma interface tem as seguintes características:
								<ul>
									<li>Uma interface não pode ser instanciada, mas podem ser definidas referências do seu tipo:
<pre>
public interface Mobilidade {

    public void andarFrente();
    public void andarTras();
    public void parar();
    public void virarDireita(int graus);
    public void virarEsquerda(int graus);
}

public class Robo implements Mobilidade{

}

public class Main {
      
    public static void main(String args[]){
        Mobilidade robo= new Robo();

    }
}
</pre>
									</li>
									<li>Todos os métodos definidos são implicitamente do tipo <i>public</i> e <i>abstract</i>. Os métodos não podem ter corpo definido, somente definimos sua assinatura:
<pre>
public interface Mobilidade {

    public void andarFrente();
    public void andarTras();
    public void parar();
    public void virarDireita(int graus);
    public void virarEsquerda(int graus);
}
</pre>
									</li>
									<li>Uma interface pode estender mais de uma <i>interface</i>. É importante observar que uma classe pode estender (herdar) somente de uma outra classe.
<pre>
public interface Mobilidade {

    public void andarFrente();
    public void andarTras();
    public void parar();
    public void virarDireita(int graus);
    public void virarEsquerda(int graus);
}

public interface Trajeto {
    
    public void destino(Double latitude, Double longitude);
    
}

public class Carro implements Mobilidade, Trajeto{

}
</pre>
									</li>
									<li>A classe que implementa uma interface deve obrigatoriamente implementar todos os métodos definidos na interface.</li>
									<li>Uma interface é formalmente uma classe abstrata, somente com atributos contantes (final) e estáticos (static) e métodos sem corpo. Estes deverão ser implementados pelas classes que irão implementar a interface. É importante observar que os atributos na interface precisam ser inicializados:
<pre>
public interface MinhaInterface {
	public static final int var01 = 100;
	public static final Double var02 = 90.90;

}
</pre>
									</li>
								</ul>
							</blockquote>

							<div class="alert alert-success" role="alert"><h4>Exercícios de fixação:</h4>
								<p>1) Crie um projeto interfaces e crie a interface <i>AreaCalculavel</i>:
<pre>
interface AreaCalculavel {
  double calculaArea();
}
</pre>
									<ul>	
										<li>Agora crie a classe Quadrado e Retangulo, ambas devem implementar a interface <i>AreaCalculavel</i>, lebrando que para calcular a área do quadrado você precisa inserir um atributo inteiro <i>lado</i> e, para calcular a área do retangulo você precisa inserir os atributos <i>largura</i> e <i>altura</i>, ambas de tipo inteiro.
										</li>
									</ul>
								</p>
								<p>2) Nosso banco precisa tributar dinheiro de alguns bens que nossos clientes possuem. Para isso, vamos criar uma interface <i>Tributavel</i>:
<pre>
public interface Tributavel {
  double calculaTributos();
}
</pre>
Alguns bens são tributáveis e outros não, <i>ContaPoupanca</i> não é tributável, já para <i>ContaCorrente</i> você precisa pagar 1% da conta e o <i>SeguroDeVida</i> tem uma taxa fixa de 42 reais.
<img src="img/exercicio2_interface.PNG" alt="Diagrama de Classes" class="img-thumbnail img-responsive center-block">
Baseado no diagrama de classes acima, implemente as classes e métodos necessários para o cálculo dos tributos do nosso banco.
								
								</p>
																
							</div>
						</div>    			
  			</li>
			<li class="list-group-item">
    			<h4 class="list-group-item-heading">Tratamento de exceções</h4>   

				<!-- *************************   Content ******************************************-->
    			<button class="btn btn-default" onclick="showContent(this);">Exibir</button>
				<div class="hide">
					<hr>				
					<h3>Tratamento de Exceções</h3>
					<blockquote>
						O tratamento de excessão oferece um poderoso mecanismo para evitar que um programa Java pare de funcionar de forma inesperada e permite que o erro seja analisado e o programa continue a ser executado normalmente.
					</blockquote>
					<blockquote>
						Um excessão deve ser vista como um retorno alternativo da execução de algum método.
						<ul>
							<li>O processo de gerar uma exceção é chamado de <strong>lançamento de exceção</strong>, e o de processar uma excessão é chamado de <strong>captura da exceção</strong>.
<pre>
import java.util.Scanner;

public class ExemploCapturaExcecao {
	public static void main(String[] args) {
		double nota = 0.0;
		System.out.println("Entre com uma nota: ");
		Scanner s = new Scanner(System.in);
		nota = s.nextInt();

		try {
			if (nota >= 70) {
				// lancando a excecao
				throw new Exception("Aprovado");
			} else if ((nota >= 40) && (nota < 70)) {
				throw new Exception("Exame");
			} else {
				throw new Exception("Reprovado");
			}
			// capturando a excecao
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
	}
}
</pre>
</li>
							
						</ul>
					</blockquote>

					<blockquote>
						Comandos try e catch
						<ul>
							<li>Toda exceção lançada representa um objeto que armazena informações sobre a ocorrência de um erro ou alguma situação não-usual do programa, como a impossibilidade de realizar um saque. Caso uma exceção não seja capturada por nenhum método do programa, o programa irá terminar com erro.</li>
							<li>Para capturar um exceção devemos colocar o código passível de lançamento de exceção em um bloco dos comandos try e catch.</li>
							<li>Todas as linhas que podem lançar um exceção devem ficar no bloco try.</li>
							<li>Para capturar a exceção devemos usar a palavra catch.</li>
							<li>Um bloco try pode estar relacionado a mais de uma bloco catch, mas um bloco try sozinho apresenta erro de compilação.</li>
							<li>Cada bloco catch manipula um tipo de exceção indicado por seu parâmetro. O tipo do parâmetro indica o tipo de exceção a ser tratada pelo bloco catch e deve ser uma classe que se estenda da classe <i>Throwable</i>.</li>
						</ul>
<pre>
public class ExemploCatchSeletivo {

    public static void main(String args[]) {
            
        try {
            int num = Integer.parseInt(args[0]);
            int num2 = Integer.parseInt(args[1]);
            //int num=40, num2=50;
            System.out.println(num);
            System.out.println(num / num2);
            if (num2 > num) {
                throw new Exception("Segundo parâmetro maior que o primeiro");
            }
        } catch (ArrayIndexOutOfBoundsException e1) {
            System.out.println("Não foi fornecido um argumento.");
        } catch (NumberFormatException e2) {
            System.out.println(" Argumento não é um inteiro.");
        } catch (ArithmeticException e1) {
            System.out.println(" Divisão de número por zero.");
        } /*
         * caso o bloco contendo a classe Exception seja colocado antes dos
         * outros tipos de exceptions darao erro de compilacao.
         */ catch (Exception e1) {
            System.out.println("Erro geral.");
        }
    }
}
</pre>
					</blockquote>
					<blockquote>
						Comando <i>throw</i>
						<ul>
							<li>É importante observar que antes de ser possível capturar uma exceção com o comando catch precisamos lança-la com o comando <i>throw</i>.</li>
							<li>Não podemos confudir com o comando <i>throws</i> usado na assinatura dos métodos para formalizar que o método lança uma exceção em vez de capturá-lo.</li>
							<li>Qualquer código pode usar o comando <i>throw</i> para realizar o lançamento de uma exceção.</li>							
						</ul>
					</blockquote>

					<blockquote>
						Hierarquia das Classes de Exceção Java
						
						<ul>
							<li>A plataforma Java fornece uma numerosa quantidade de classes de exceção para uso nas mais diferentes situações de erro.</li>
							<li>As classes Error, Exception e RuntimeException definem os três diferentes tipos de exceções que podemos ter.</li>
							<li><img src="img/hierarquia_excecoes.gif" alt="Hierarquia de Classes de Exceções em JAVA" class="img-thumbnail img-responsive center-block"></li>
							<li>Como podemos observar na figura, a superclasse de todas as classes responsáveis pelo tratamento de erros é a classe Throwable. As classes Error e Exception são suas subclasses diretas.</li>
							<li>A classe Error deve ser usada para o tratamento de erros graves geralmente causados pelo mau funcionamento de dispositivos de hardware. Nenhum programa Java deve lançar ou capturar esse tipo de exceção.</li>
							<li>A classe Exception é a superclasse de todas as exceções possíveis de serem lançadas por problemas no momento da execução do programa em Java. Qualquer exceção desenvolvida pelo programador sempre deverá estended a classe Exception. Exceções que estendem a classe Exception definem exceções do tipo <i>checked</i>.</li>
							<li>A classe RuntimeException que estende Exception define que uma exceção será classificada como <i>unchecked</i>, ou seja, exceções que não precisam ser explicitamente informadas na assinatura do método quando for possível lançá-las, por exemplo:
								<ul>
									<li>NullPointerException</li>
									<li>IndexOutofBoundsException</li>
									<li>ArithmeticException</li>
								</ul>
</li>
						</ul>
					</blockquote>

					<blockquote>
						Métodos da Classe <i>throwable</i>
						<ul>
							<li>String getMessage() - Este método retorna a descrição usada na criação da exceção.</li>
							<li>void printStacktrace() - Este método apresenta todas as informações da pilha no momento da exceção, ou seja, exibe qual o método gerou a exceção e quais métodos tinham sido executados no momento do erro.</li>
						</ul>
					</blockquote>

					<blockquote>
						Comando <i>finally</i>
						<ul>
							<li>Um finally sempre será executado após um bloco try.</li>
							<li>Todas as linhas de um bloco finally serão executados mesmo que ocorra o lançamento de uma exceção.</li>
							<li>Como boa prática devemos sempre realizar o fechamento de arquivos, conexões com banco de dados e a liberação de algum outro recurso em um bloco finally.</li>
						</ul>
					</blockquote>

					<blockquote>
						Como criar classes de negócio para tratamento de exceções</i>
						<p>Primeiro é preciso definir se a classe estenderá a Exception ou RuntimeException. Adicionar atributos necessários para o controle de erro, pois ajudarão na identificação e solução do problema. Como boa prática, uma classe deve ter pelo menos quatro métodos.</p>
						<ul>
							<li>1º) A classe deve ter um construtor sem argumentos executando o constrututor da superclasse.
<pre>
public MyClassException() {
			super();
	}
</pre>
</li>
							<li>2º) No segundo, deve haver um construtor que receba um objeto do tipo throwable.
<pre>
	public MyClassException(Throwable arg0) {
			super(arg0);
	}
</pre>
</li>
							<li>3º) No terceiro, deve haver um construtor que receba uma String e um objeto do tipo Trowable. 
<pre>
public MyClassException(String arg0, Throwable arg1) {
	super(arg0, arg1);
}
</pre>
</li>
							<li>4º) No quarto, deve haver um construtor que receba uma String. Esse método poderá transportar a mensagem de erro gerada.
<pre>
	public MyClassException(String p_str) {
			super(p_str);
	}
</pre></li>
						</ul>

Exemplo completo:
<pre>
public class MyClassException extends Exception {
	private String mensagem = " ";
	private String classe = " ";
	private String pacote = " ";
	private String metodo = " ";
	public MyClassException() {
			super();
	}
	public MyClassException(String p_str) {
			super(p_str);
	}
	public MyClassException(Throwable arg0) {
			super(arg0);
	}
	public MyClassException(String arg0, Throwable arg1) {
			super(arg0, arg1);
	}
	public void setClasse(String pclasse) {
			this.classe = pclasse;
	}
	public String getClasse() {
			return this.classe;
	}
	public void setMensagem(String pmensagem) {
			this.mensagem = pmensagem;
	}
	public String getMensagem() {
			return this.mensagem;
	}
	public void setPacote(String ppacote) {
			this.pacote = ppacote;
	}
	public String getPacote() {
			return this.pacote;
	}
	public void setMetodo(String pmetodo) {
			this.metodo = pmetodo;
	}
	public String getMetodo() {
			return this.metodo;
	}
}
</pre>
					</blockquote>

<div class="alert alert-success" role="alert"><h4>Exercícios de fixação:</h4>
<p>1) Construa uma classe de tratamento de exceções para a classe a seguir.</p>	
<pre>
import java.util.Scanner;
/**
 *
 * @author fernandommota
 */
public class inverteValores {
    
    public inverteValores(){
        int i, temp;
        Scanner s = new Scanner(System.in);
        
        System.out.println("Insira um valor para N:");
        int n = s.nextInt();
        
        int vetor[] = new int[n];
        for(i=0; i< n; i++){
           System.out.println("Insira um valor para a posição "+(i+1)+":");
           vetor[i] = s.nextInt();
        }        
        
        for(i=0; i< (n/2); i++){
           temp=vetor[i];
           vetor[i] = vetor[(n-i)-1];
           vetor[(n-i)-1] = temp;
        }
        
        for(i=0; i< n; i++){
            System.out.println("Posição ["+(i+1)+"]: "+vetor[i]);
        }
    }
    
    public static void main(String args[]){
        inverteValores obj= new inverteValores();
    }
}
</pre>							
					</div>	
			<blockquote>		
				Exercícios Extras
				<a class="btn btn-primary btn-lg" href="files/excecoes.pdf" target="no_blank" title="Download">
					<span class="glyphicon glyphicon-download-alt"></span>
				</a>
			</blockquote>			
			</div>
 			</li>
			<li class="list-group-item">
    			<h4 class="list-group-item-heading">Estudo de Caso envolvendo aplicação Desktop</h4>
				<blockquote>		
					Tópicos em Interface
					<a class="btn btn-primary btn-lg" href="files/InterfaceGrafica.pdf" target="no_blank" title="Download">
						<span class="glyphicon glyphicon-download-alt"></span>
					</a>
				
					<br><br><br>

					<table class="table table-bordered">
						<tr>
							<th>Classe</th>
							<th>Download</th>
						</tr>
						<tr>
							<td>LabelTest</td>
							<td>
								<a class="btn btn-primary btn-lg" href="files/LabelTest.zip" target="no_blank" title="Download">
									<span class="glyphicon glyphicon-download-alt"></span>
								</a>	
							</td>
						</tr>
						<tr>
							<td>ButtonTest</td>
							<td>
								<a class="btn btn-primary btn-lg" href="files/ButtonTest.java" target="no_blank" title="Download">
									<span class="glyphicon glyphicon-download-alt"></span>
								</a>	
							</td>
						</tr>
						<tr>
							<td>CheckBoxTest</td>
							<td>
								<a class="btn btn-primary btn-lg" href="files/CheckBoxTest.java" target="no_blank" title="Download">
									<span class="glyphicon glyphicon-download-alt"></span>
								</a>	
							</td>
						</tr>
						<tr>
							<td>ComboBoxTest</td>
							<td>
								<a class="btn btn-primary btn-lg" href="files/ComboBoxTest.java" target="no_blank" title="Download">
									<span class="glyphicon glyphicon-download-alt"></span>
								</a>	
							</td>
						</tr>
						<tr>
							<td>KeyDemo</td>
							<td>
								<a class="btn btn-primary btn-lg" href="files/KeyDemo.java" target="no_blank" title="Download">
									<span class="glyphicon glyphicon-download-alt"></span>
								</a>	
							</td>
						</tr>
						<tr>
							<td>ListTest</td>
							<td>
								<a class="btn btn-primary btn-lg" href="files/ListTest.java" target="no_blank" title="Download">
									<span class="glyphicon glyphicon-download-alt"></span>
								</a>	
							</td>
						</tr>
						<tr>
							<td>MouseTracker</td>
							<td>
								<a class="btn btn-primary btn-lg" href="files/MouseTracker.java" target="no_blank" title="Download">
									<span class="glyphicon glyphicon-download-alt"></span>
								</a>	
							</td>
						</tr>
						<tr>
							<td>TextFieldTest</td>
							<td>
								<a class="btn btn-primary btn-lg" href="files/TextFieldTest.java" target="no_blank" title="Download">
									<span class="glyphicon glyphicon-download-alt"></span>
								</a>	
							</td>
						</tr>
					</table>
								
			</blockquote>
  			</li>
		</ul>

		<hr>	

		<h3>Bibliografia</h3>
		<h4>Básica</h4>
		<ul class="list-group">
			<li class="list-group-item list-group-item-danger">DEITEL, H.M.; DEITEL, P. J. Java: how to program. 7. ed. New York: Prentice-Hall, 2007.</li>
			<li class="list-group-item list-group-item-danger">MECENAS, I. Java 2: fundamentos, swing e JDBC. Rio de Janeiro: Alta Books, 2003.</li>
			<li class="list-group-item list-group-item-danger">POO, D. et al. Object-oriented programming and Java. 2. ed. Berlin: Springer, 2007.</li>
		</ul>

		<h4>Complementar</h4>
		<ul class="list-group">
			<li class="list-group-item list-group-item-info">BOOCH, G. et al. UML – Guia do usuário. 2. ed. Rio de Janeiro: Campus, 2005.</li>
			<li class="list-group-item list-group-item-info">DEITEL, H. M.; DEITEL, P. J. C++: How to program. 5. ed. New York: Prentice-Hall, 2005.</li>
			<li class="list-group-item list-group-item-info">GAMMA, E. et al. Design patterns: elements of reusable object-oriented software. New York: Addison-Wesley, 1994.</li>
		</ul>
	</body>
	<script language="javascript" type="text/javascript">
function showContent(element){
	var divContent= $(element).next();
	var button = $(element);
	var li=$(element).parent();

	if(divContent.hasClass("hide")){
		//li.addClass("active");
		divContent.removeClass("hide");
		divContent.addClass("show");	
		button.text("Esconder");
	}else{
		//li.removeClass("active");
		divContent.removeClass("show");
		divContent.addClass("hide");	
		button.text("Exibir");
	}	
}
	</script>
</html>


