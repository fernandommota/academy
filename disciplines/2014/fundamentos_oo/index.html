<!doctype html>
<html>
	<head>
		<meta charset="utf-8">		

		<link rel="stylesheet" href="../../../css/styles.css">
		<link rel="stylesheet" href="../../../lib/bootstrap/css/bootstrap.min.css">
		

		<script src="../../../js/jquery-2.1.1.min.js"></script>
		<script src="../../../lib/bootstrap/js/bootstrap.min.js"></script>

		<!--[if lt IE 9]>
		<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
	</head>
	<body>
		<h3>Avisos</h3>
			<blockquote class="alert alert-warning">				
				<a class="btn btn-primary btn-lg" href="files/lista_1.pdf" target="no_blank" title="Download">
					<span class="glyphicon glyphicon-download-alt"></span>
				</a>
				lista 1 de exercicios.<strong>Entrega até dia 05/09/2014.</strong>
			</blockquote>
		<hr>
		<h3>Horário de atendimento</h3>
		??
		<hr>
		<h3>Avaliação</h3>
			<ul>
				<li>2 Provas teóricas: <var>P1</var> e <var>P2</var></li>
				<li>1 Prova optativa: <var>PO</var></li>
				<li>1 Trabalhos práticos: <var>T1</var></li>
				<li>4 Listas de exercício: <var>L1</var>, <var>L2</var>, <var>L3</var> e <var>L4</var></li>
			</ul>
			
			<strong>Média de aproveitamento:</strong> 
			(((<var>P1</var> + <var>P2</var>) / 2) * 0.6) + (<var>T1</var> * 0.2) + ((<var>L1</var> + <var>L2</var> + <var>L3</var> + <var>L4</var>) * 0.2))) 

		<hr>	
		<h3>Datas</h3>
			<strong>As aulas serão ministradas as quartas e sextas-feiras, das 21:00 às 23:00.</strong>
			<iframe src="https://www.google.com/calendar/embed?showTitle=0&amp;showDate=0&amp;showPrint=0&amp;showCalendars=0&amp;mode=MONTH&amp;height=400&amp;wkst=1&amp;hl=pt_BR&amp;bgcolor=%23ffffff&amp;src=lno19j9n65nhctft123vn7158s%40group.calendar.google.com&amp;color=%232952A3&amp;ctz=America%2FCampo_Grande" style=" border-width:0 " width="100%" height="400" frameborder="0" scrolling="no"></iframe>
		<hr>

		<h3>Ementa</h3>
		<ul class="list-group ementa">
			<li class="list-group-item">
    			<h4>Fundamentos da Programação Orientada a Objetos</h4>
    			<ul>
					<li>Objeto</li>
					<li>Classe</li>
					<li>Membros de classe</li>
				</ul>				
				<!-- *************************   Content ******************************************-->
    			<button class="btn btn-default" onclick="showContent(this);">Exibir</button>
				<div class="hide">
					<hr>

					<blockquote class="blockquote-reverse">
						Agradecimento ao professor Marcelo Ferreira Siqueira pelo material utilizado nesta disciplina.
						<footer><a href="http://lattes.cnpq.br/7340736676138238" target="no_blank">Currículo Lattes</a></footer>
					</blockquote>

					<blockquote>
						Aula 1 - Introdução à Orientação a Objetos
						<a class="btn btn-primary btn-lg" href="files/aula01.pdf" target="no_blank" title="Download">
							<span class="glyphicon glyphicon-download-alt"></span>
						</a>
					</blockquote>

					<blockquote>
						Aula 2 - Introdução à Orientação a Objetos (Continuação)
						<a class="btn btn-primary btn-lg" href="files/aula02.pdf" target="no_blank" title="Download">
							<span class="glyphicon glyphicon-download-alt"></span>
						</a>
					</blockquote>
<!--
					<blockquote class="blockquote-reverse">
						Agradecimento ao professor Marcelo Ferreira Siqueira pelo material utilizado nesta aula.
						<footer><a href="http://lattes.cnpq.br/7340736676138238" target="no_blank">Currículo Lattes</a></footer>
					</blockquote>
					<h4>Por Que Orientação a Objetos?</h4>
					<blockquote>
							<p>A construção de sistemas de software é um processo intrinsicamente complexo e tem se tornado ainda mais complexo devido aos novos requisitos impostos às aplicações modernas:</p>
								<ul>
									<li>Alta confiabilidade</li>
									<li>Alto desempenho</li>
									<li>Desenvolvimento rápido e barato</li>
									<li>Tamanho</li>
									<li>Grande complexidade</li>
								</ul>							
					</blockquote>
					<blockquote>
						<p>É possível, e muitas vezes até desejável, utilizar métodos e técnicas que nos permitem ignorar ou reduzir a complexidade de tal processo em algumas de suas etapas, mas isso não faz com que a complexidade desapareça, pois ela certamente aparecerá em uma outra etapa.</p>
						<p>Os desenvolvedores de software já reconheceram há bastante tempo que a chave para o sucesso no desenvolvimento de softwares está no controle da sua complexidade.</p>
						<p>O surgimento de linguagens de programação de alto nível e os seus compiladores é um exemplo.</p>
					</blockquote>
					<blockquote>
						<p>Em 1968, na Conferência de Engenharia de Software da NATO (Conference on Software Engineering - Conferência sobre Engenharia de Software da OTAN), utilizou-se pela primeira vez o termo "crise do software" para designar o mal momento que atravessava a indústria de software, que não possuía métodos adequados para suprir suas demandas.</p>
						Exemplos de problemas encontrados:
							<ul>
								<li>Baixa qualidade</li>
								<li>Alto custo de manutenção</li>
								<li>Duplicação de esforços no processo de construção</li>
							</ul>							
						<p>A partir daí surgiram muitos métodos para o desenvolvimento de software, todos eles com o intuito de superar a tal "crise do software". Neste contexto, surgiu o <strong>paradigma da orientação a objetos</strong>.</p>
						<p>Muitas são as razões que fazem o paradigma da orientação a objeto um modelo promissor e mais confiável do que os demais para o gerenciamento da complexidade do desenvolvimento de software.</p>
						Mas talvez a principal razão seja mesmo o simples fato de que todos os bons princípios de projeto de software conhecidos até o momento são inerentes ao modelo de objetos:
							<ul>
								<li>Abstração de dados</li>
								<li>Modularização</li>
								<li>Encapsulamento</li>
								<li>Herança e reutilização de código</li>
							</ul>	
						<p>O fato de muitos desses princípios existirem antes do surgimento do paradigma da orientação a objetos fez com que o surgimento do modelo de objetos seja visto mais como uma <strong>evolução do que como uma revolução</strong>.</p>
					</blockquote>

					<hr>
					<h4>Programação Orientada a Objetos</h4>

					<blockquote>
						<p>A programação orientada a objetos é frequentemente tida como um novo paradigma de programação.</p>
						<p>Por paradigma, entendemos um conjunto de teorias, métodos e padrões que juntos representam uma forma de organizar o conhecimento, isto é, uma forma de ver o mundo.</p>			
					</blockquote>
					<blockquote>
						<p>Ao tentarmos entender exatamente o que significa o termo programação orientada a objetos, é interessante examinar a ideia a partir de várias perspectivas. Para tal, considere o seguinte exemplo:</p>						
						<p><em>Suponha que eu deseje enviar flores para a minha namorada pelo nosso aniversário de namoro. Ela agora está na cidade de Presidente Prudente e, portanto, a quilômetros de Coxim. Obviamente, eu pegar as flores e levá-las pessoalmente até lá está fora de questão. Entretanto, enviá-las para ela é uma tarefa razoavelmente fácil. Eu meramente vou a uma floricultura local, onde trabalha o florista Florisvaldo, informo-lhe o tipo e o número de flores que eu quero enviar e o endereço da minha namorada, e posso estar certo de que as flores serão segura e automaticamente entregues a tempo.</em></p>
						
						<ul>
							<li>O mecanismo que eu usei para resolver o problema da entrega das flores foi encontrar um <strong>agente</strong> adequado (chamado Florisvaldo) e enviá-lo uma <strong>mensagem</strong> contendo a minha solicitação.</li>	
							<li>É responsabilidade de Florisvaldo cumprir minha solicitação.</li>
							<li>Há algum método (algum algoritmo ou conjunto de operações) usado por Florisvaldo para fazer o que eu pedi. Esta informação é comumente <strong>ocultada</strong> de mim.</li>
							<li>Entretanto, se eu investigar, descobrirei que Florisvaldo entrega uma mensagemn ligeiramente diferente para um outro florista em Presidente Prudente. Este florista, por sua vez, toma as devidas providências e passa as flores, através de uma outra mensagem, para seu entregador e assim por diante. Desta forma, minha solicitação é finalmente cumprida por uma sequência de solicitações de um agente para outro.</li>
							<hr>
							<li><strong>Nosso primeiro princípio de resolução de problemas de forma orientada objetos é o veículo pelo qual as atividades são iniciadas. Na programação orientada a objetos, a ação é iniciada através da transmissão de uma mensagem para um agente (um objeto) responsável pela ação.</strong></li>
							<li>A mensagem codifica o pedido de realização da ação e é acompanhada de quaisquer informações adicionais (argumentos) necessários à execução do pedido.</li>
							<li>O receptor é o agente para quem a mensagem é enviada.</li>
							<li>Se o receptor aceita a mensagem, ele aceita a responsabilidade de cumprir a ação indicada. Em resposta à mensagem, o receptor executará algum método que satisfaça o pedido.</li>
							<hr>
							<li>Embora tenha lidado com Florisvaldo apenas umas poucas vezes, eu tenho uma idéia geral de seu comportamento quando vou a sua loja e apresento a minha solicitação.</li>
							<li>Eu sou capaz de assumir certas verdades acerca do comportamento dele porque eu tenho alguma informação sobre floristas em geral, e eu espero que Florisvaldo, sendo um membro desta categoria, comporte-se como tal.</li>
							<li>Podemos usar o termo Florista para representar a categoria (ou <strong>classe</strong>) de todos os floristas.</li>
							<li><strong>Segundo princípio de programação orientada a objetos: todos os objetos são ocorrências de uma classe.</strong></li>
							<li>O método invocado por um objeto em resposta a uma mensagem é determinado pela classe do receptor.</li> 
							<li>Todos os objetos de uma dada classe utilizam o mesmo método em resposta a mensagens similares.</li>
						</ul>
					</blockquote>
-->
				</div>
  			</li>
			<li class="list-group-item">
    			<h4 class="list-group-item-heading">Propriedades da Orientação a Objetos</h4>
    			<ul>
					<li>Encapsulamento</li>
					<li>Herança</li>
					<li>Polimorfismo</li>
				</ul>

				<!-- *************************   Content ******************************************-->
    			<button class="btn btn-default" onclick="showContent(this);">Exibir</button>
				<div class="hide">
					<hr>
					<h4>Herança</h4>
					
					<blockquote class="blockquote-reverse">
						Códigos disponibilizados para esta aula (herança).
						<a class="btn btn-primary btn-lg" href="files/heranca.zip" target="no_blank" title="Download">
							<span class="glyphicon glyphicon-download-alt"></span>
						</a>
					</blockquote>

					<blockquote class="blockquote">
						<p>O conceito de herança esta fundamentado na definição de uma classe com base em outra.</p>
						<p>A outra classe usada como referencial pode ser chamada de superclasse, classe-mãe, classe-base ou generalização.</p>
						<p>A nova classe criada a partir da outra passa a ser subclasse, classe-filha, classe derivada ou especialização. Podemos redefinir métodos e criar novos atributos na subclasse.</p>
					</blockquote>

					<blockquote class="blockquote">
						<p>Sobreposição de métodos é quando em herança podemos definir novos métodos e atributos na subclasse, podemos também redefinir um método na subclasse com a mesma assinatura do método da superclasse.</p>
					</blockquote>

					<blockquote class="blockquote">
						<p>Quando criamos um objeto de uma subclasse, devemos lembrar que ao executar o seu construtor primeiramente será executado o construtor da superclasse de forma automática.</p>
						<p>Podemos executar na subclasse qualquer construtor da superclasse utilizando o comando <strong>super</strong>.</p>
					</blockquote>

					<blockquote class="blockquote">
						<p>Uma classe abstrata é desenvolvida para representar classes e conceitos abstratos.</p>
						<p>A classe abstrata é sempre uma superclasse que não permite que nenhum objeto seja criado a partir dela, ou seja, não se pode executar a operação de new usando uma classe abstrata.</p>
					</blockquote>

					<blockquote class="blockquote">
						<p>Os modificadores de acesso são palavras reservadas que modificam a forma de acesso a classes, métodos e/ou atributos.</p>
						<p>Classe final é quando uma classe não pode ser herdada por nenhuma outra. Um exemplo de classe final é a String.</p>
						<p>A razão para uso do modificador final é garantir certas regras de segurança ou projeto sejam seguidas.</p>
						<p>Métodos do tipo final não podem ser redefinidos, ou seja, caso você herde de uma classe que contenha métodos com esse modificador, esses métodos não podem ser sobrescritos (override) na subclasse.</p>
						<p>Por exemplo, você possui um método final <code>validarSenha()</code>, alguém mal-intencionado poderia alterar esse método em uma subclasse e passar a usar esse método em vez do definido pelo arquiteto do sistema.</p>
					</blockquote>

					<div class="alert alert-success" role="alert"><h4>Exercícios de fixação:</h4>
						Defina as seguintes classes que representam um sistema de bibliotecas, Ps. para cada livro emprestado um registro de empréstimo deve ser realizado:
						<ul>
							<li>Crie a classe Livro com os seguintes atributos: autor, ano de publicação, editora, nome do livro e código.</li>
							<li>Crie a classe Pessoa com os seguintes atributos: nome, idade, endereço e CPF.</li>
							<li>Na classe pessoa defina o método <code>imprimirMatricula</code>, onde os atributos nome e CPF devem ser impressos.</li>
							<li>Crie a classe Docente herdando da classe Pessoa, nesta classe deve ser inserida um atributo que represente o número de matricula geral do docente que possui no máximo 8 caracteres. Ex. "CPCX2014" </li>
							<li>Na classe Docente defina o método <code>imprimirMatricula</code>, onde os atributos nome e código de matricula geral do docente devem ser impressos.</li>
							<li>Crie a classe Aluno herdando da classe Pessoa, nesta classe deve ser inserida um atributo que represente o número de matricula geral do aluno que possui no máximo 6 números. Ex. "201418" </li>
							<li>Na classe Aluno defina o método <code>imprimirMatricula</code>, onde os atributos nome e código de matricula geral do aluno devem ser impressos.</li>
							<li>Crie a classe abstrata Empréstimo com os seguintes métodos e argumentos:
								<ul>
									<li><code>devolver();</code></li>
									<li><code>renovar(quantidadeDias);</code></li>								
								</ul>							
							</li>							
							<li>Crie as classes EmprestimoDocente e EmprestimoAluno, ambas devem herdar da classe Empréstimo e em seu construtor devem ser instanciados os atributos Livro e Docente, Livro e Aluno respectivamente.</li>
						</ul>		
					</div>

					<blockquote class="blockquote">
						<p>Formas de Herança:</p>
						<ul>
							<li><strong>Especialização</strong>. Provavelmente, o uso mais comum de herança é por especialização. Neste uso, a classe nova é uma forma especializada da classe pai, mas satisfaz as especificações da classe pai em todos os aspectos relevantes.</li>
							<li><strong>Generalização</strong>. Usar herança por generalização é, de certa forma, o oposto de especialização. Aqui, uma subclasse estende o comportamento da classe pai para criar um tipo mais geral de objeto. Generalização é frequentemente aplicada quando construímos uma base de classes existentes que não desejamos modifícar ou não podemos modifícar.</li>
							<li><strong>Limitação</strong>. Limitação ocorre quando o comportamento da subclasse é menor ou mais restritivo do que o comportamento da classe pai. Assim como generalização, limitação ocorre mais frequentemente quando um programador está construindo sobre uma base de classes existentes que não deveria, ou não pode, ser modifícada.</li>
							<li><strong>Especificação</strong>. Um uso frequente de herança é para garantir que classes mantenham uma certa interface comum, isto é, implementem os mesmos métodos. A classe pai pode ser uma combinação de operações implementadas e operações que são "deixadas" para ser implementadas pelas classes fílhas. Frequentemente, não há mudança de interface de nenhuma ordem entre a classe pai e a classe fílha: a classe fílha meramente implementa o comportamento descrito, mas não implementado, pela classe pai. Especificação é de fato um caso especial de especialização, exceto que as subclasses não são refinamentos de um tipo existente, mas sim realizações de uma especificação abstrata e incompleta. Em tais casos, a classe pai é algumas vezes conhecida como classe de especificação abstrata.</li>
							<li><strong>Combinação</strong>. Uma situação comum é uma subclasse representar uma combinação de características de duas ou mais classes pai. Um monitor de ensino pode possuir características tanto de um professor quanto de um estudante e pode, portanto, comportar-se como ambos. A capacidade de uma classe herdar de duas ou mais classes pais é conhecida como herança múltipla.</li>
						</ul>
					</blockquote>

					<blockquote class="blockquote">
						<p>A Regra "é um" e a Regra "tem um":</p>
						<ul>
							<li>Um entendimento de duas formas diferentes de relacionamento entre classes e objetos é fundamental para saber como e quando aplicar técnicas de reuso de software orientado a objetos. Estes dois relacionamentos são conhecidos informalmente como "é um" e "tem um" (ou "parte de").</li>
							<li>O relacionamento "é um" entre dois conceitos é satisfeito quando o primeiro é uma especialização do segundo.</li>
							<li>Por exemplo. Florista é um Vendedor, um Cachorro é um Mamífero e assim por diante.</li>
							<li>Para determinar se o conceito X é uma instância especializada do conceito Y, simplesmente forme a sentença "Um X é um Y". Se a sentença "soa bem", isto é, se ela parece corresponder à experiência do dia-a-dia, você pode assumir que X e Y possuem o relacionamento é um.</li>
							<li>O relacionamento tem um, por outro lado, é satisfeito quando o segundo conceito é um componente do primeiro, mas os dois não são, em qualquer hipótese, a mesma coisa, não importa quão abstrata seja a generalidade. Por exemplo, um Carro tem um Motor e, claramente, não faz sentido dizer que um Carro é um Motor ou um Motor é um Carro. Entretanto, um Carro é um Veículo, que por sua vez é um Meio De Transporte.</li>
							<li>Mais uma vez, o teste para o relacionamento tem um é simplesmente formar uma sentença da forma "um X tem um Y" e deixar o senso comum dizer se o resultado soa razoável.</li>
						</ul>
					</blockquote>

					<blockquote class="blockquote">
						<p>Benefícios do Uso de Herança:</p>
						<ul>
							<li><strong>Reusabilidade de código.</strong> Quando comportamento é herdado de uma outra classe, o código que fornece aquele comportamento não precisa ser reescrito. Isto parece óbvio, mas as implicações são importantes. Muitos programadores gastam muito do tempo deles reescrevendo código que eles escreveram muitas vezes antes. Por exemplo, para encontrar um padrão em uma cadeia ou inserir um novo elemento em uma tabela. Com técnicas de orientação a objetos, estas funções podem ser escritas apenas uma vez e reutilizadas.</li>
							<li><strong>Compartilhamento de código.</strong> Compartilhamento de código ocorre em muitos níveis com técnicas orientadas a objetos. Uma forma de compartilhamento se dá quando muitos usuários ou projetos podem usar as mesmas classes. Uma outra ocorre quando duas ou mais classes desenvolvidas por um único programador como parte de um projeto herda de uma única classe pai. Quando isto acontece, dois ou mais tipos de objetos compartilharão o código que eles herdaram.</li>
							<li><strong>Consistência de interface.</strong> Quando duas ou mais classes herdam da mesma superclasse, podemos estar certos de que o comportamento que elas herdaram sería o mesmo em todas as classes. Logo, é mais fácil garantir que interfaces para objetos semelhantes sejam, de fato, semelhantes e que o usuário não se depare com um conjunto confuso de objetos que são quase os mesmos mas se comportam e interagem de forma bem diferente.</li>
							<li><strong>Componentes de software.</strong> Herança permite que programadores construam componentes de software reutilizáveis. O objetivo é permitir o desenvolvimento de aplicações novas que requeiram pouca ou nenhuma codificação. Várias bibliotecas de classes reutilizáveis já se encontram disponíveis comercialmente e podemos esperar muito mais com o passar do tempo.</li>
							<li><strong>Prototipação rápida.</strong> Quando um sistema de software é grandemente construído com base em componentes reutilizáveis, o tempo de desenvolvimento pode ser concentrado em entender a parte nova do sistema. Logo, sistemas de software podem ser gerados mais facilmente e mais rapidamente, levando a um estilo de programação conhecido como prototipação rápida ou programação exploratória.</li>
							<li><strong>Ocultamento de informação.</strong> Um programador que reutiliza um componente de software necessita apenas entender a natureza do componente e sua interface. Não há a necessidade do programador ter informação detalhada a respeito de fatos como, por exemplo, as técnicas usadas para implementar o componente. Logo, a interconexão entre sistemas de software é reduzida e, consequentemente, a complexidade também é reduzida.</li>
						</ul>
					</blockquote>

					<blockquote class="blockquote">
						<p>Custos do Uso de Herança:</p>
						<ul>
							<li><strong>Velocidade de execução.</strong> Difícilmente, ferramentas de software de propósito geral são tão rápidas quanto aquelas desenvolvidas cuidadosamente para um propósito específico. Logo, métodos herdados, que devem lidar com subclasses arbitrárias são frequentemente mais lentos do que código especializado. Ainda assim, a preocupação com eficiência é geralmente desnecessária. Primeiro, a diferença e frequentemente pequena. Segundo, a redução em velocidade de execução pode ser balanceada por um aumento da velocidade de desenvolvimento de software. Finalmente, a maioria dos programadores não possui a mínima ideia de como o tempo de execução está sendo usado no programa. É muito melhor desenvolver um sistema que funcione, monitorá-lo para descobrir onde o
tempo de execução está sendo usado e melhorar aquelas seções, do que gastar uma quantidade desordenada de tempo se preocupando com eficiência no início do projeto.</li>
							<li><strong>Tamanho do programa.</strong> O uso de qualquer biblioteca de software em geral acarreta o aumento de tamanho do programa, o que não acontece com sistemas construídos através de um projeto específico. Embora este gasto possa ser substancial, quando o custo de memória for reduzido a níveis insignificantes. Conter custos de desenvolvimento e produzir código de alta qualidade e livre de erro são preocupações que se tornaram muito mais importantes do que limitar o tamanho dos programas.</li>
							<li><strong>Overhead de envio de mensagens.</strong> Muito do que tem sido feito do fato que envio de mensagens é por natureza uma operação mais custosa do que chamada de procedimento. Assim como velocidade de execução, entretanto, a preocupação neste caso também é supervalorizada, pois a diferença nos custos de envio de mensagens e chamada de procedimento é marginal. Talvez, duas ou três instruções adicionais de linguagem de montagem e um gasto adicional de 10 porcento do tempo total. Este custo, como muitos outros, pode ser balanceado pelos benefícios das técnicas de orientação a objetos.</li>
							<li><strong>Complexidade do programa.</strong> Embora a programação orientada a objetos seja tida como uma solução para a complexidade do software, o uso demasiado de herança pode simplesmente substituir uma forma de complexidade por outra. Entender o uso de controle de um programa que utiliza herança pode requerer várias varreduras no grafo de herança. Isto é conhecido como o problema do iô-iô.</li>							
						</ul>
					</blockquote>

  			</li>
			<li class="list-group-item">
    			<h4 class="list-group-item-heading">Classes e métodos abstratos</h4>    			
  			</li>
			<li class="list-group-item">
    			<h4 class="list-group-item-heading">Interfaces</h4>    			
  			</li>
			<li class="list-group-item">
    			<h4 class="list-group-item-heading">tratamento de exceções</h4>    			
  			</li>
			<li class="list-group-item">
    			<h4 class="list-group-item-heading">Estudo de Caso envolvendo aplicação Desktop</h4>
  			</li>
		</ul>

		<hr>	

		<h3>Bibliografia</h3>
		<h4>Básica</h4>
		<ul class="list-group">
			<li class="list-group-item list-group-item-danger">DEITEL, H.M.; DEITEL, P. J. Java: how to program. 7. ed. New York: Prentice-Hall, 2007.</li>
			<li class="list-group-item list-group-item-danger">MECENAS, I. Java 2: fundamentos, swing e JDBC. Rio de Janeiro: Alta Books, 2003.</li>
			<li class="list-group-item list-group-item-danger">POO, D. et al. Object-oriented programming and Java. 2. ed. Berlin: Springer, 2007.</li>
		</ul>

		<h4>Complementar</h4>
		<ul class="list-group">
			<li class="list-group-item list-group-item-info">BOOCH, G. et al. UML – Guia do usuário. 2. ed. Rio de Janeiro: Campus, 2005.</li>
			<li class="list-group-item list-group-item-info">DEITEL, H. M.; DEITEL, P. J. C++: How to program. 5. ed. New York: Prentice-Hall, 2005.</li>
			<li class="list-group-item list-group-item-info">GAMMA, E. et al. Design patterns: elements of reusable object-oriented software. New York: Addison-Wesley, 1994.</li>
		</ul>
	</body>
	<script language="javascript" type="text/javascript">
function showContent(element){
	var divContent= $(element).next();
	var button = $(element);
	var li=$(element).parent();

	if(divContent.hasClass("hide")){
		//li.addClass("active");
		divContent.removeClass("hide");
		divContent.addClass("show");	
		button.text("Esconder");
	}else{
		//li.removeClass("active");
		divContent.removeClass("show");
		divContent.addClass("hide");	
		button.text("Exibir");
	}	
}
	</script>
</html>


